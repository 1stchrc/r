# 简单DP

**DP：** 动态规划（Dynamic Programming）是一种通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。由于动态规划并不是某种具体的算法，而是一种解决特定问题的方法，因此它会出现在各式各样的数据结构中，与之相关的题目种类也更为繁杂。

## [例题：洛谷B3635-硬币问题](https://www.luogu.com.cn/problem/B3635)

## 题目描述

今有面值为 1、5、11 元的硬币各无限枚。

想要凑出 $n$ 元，问需要的最少硬币数量。

## 输入格式

仅一行，一个正整数 $n$。

## 输出格式

仅一行，一个正整数，表示需要的硬币个数。

## 样例 #1

### 样例输入 #1

```
15
```

### 样例输出 #1

```
3
```

## 样例 #2

### 样例输入 #2

```
12
```

### 样例输出 #2

```
2
```

## 提示

#### 样例解释

对于样例数据 1，最佳方案是 $15=5+5+5$，使用到 3 枚硬币。

对于样例数据 2，最佳方案是 $12=11 + 1$，使用到 2 枚硬币。

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $n\leq 10^6$。

## 题解

设凑出 $n$ 元所需最少硬币数量为 $F_n$ ，不难发现$F_n = min(F_{n-1}, F_{n-5}, F_{n-11}) + 1$ ，前提是我们认为当 $n < 0$ 时 $F_n = +\infty$ ，$n=0$ 时 $F_n = 0$。

我们可以将该方程翻译成C语言函数：

```cpp
int F(int n){
    if(n < 0)return 0x7fffffff;
    if(!n)return 0;
    return std::min(F(n-1), std::min(F(n-5), F(n-11))) + 1;
}
```

但是当我们实际利用这个函数来解决这个问题的时候会TLE。

分析算法复杂度，设 $F_n$ 的计算时长为 $f(n)$ ，可以得到 $f(n) = f(n-1) + f(n-5) + f(n-11)$ ，很明显 $f$ 是单调递增的，故 $f(n) > 3f(n-11)$ ，因此该方法的时间复杂度大于 $O(3^{\frac{n}{11}})$ ，而本题数据范围上限为 $10^6$ ，时间复杂度不可接受。

要优化该算法，不难发现，如果我们在计算 $F_n$ 前先将 $<n$ 的 $F$ 值计算并储存起来，每次计算 $F_n$ 的时候直接访问已经储存起来的 $F$ 值而不是重新计算，那么每次计算一个 $F$ 值时所用的时间为常数，计算 $F_n$ 需要计算 $n$ 次，故总时间复杂度为 $O(n)$ ，可以接受。

代码：
```cpp
#include<iostream>
using namespace std;
constexpr int N = 1e6;
int arr[N + 12];
int* F = arr + 11;

int main(){
    fill(F - 11, F, 0x7fffffff);
    F[0] = 0;
    int n;
    cin >> n;
    for(int i = 1; i <= n; ++i){
        F[i] = min(F[i - 1], min(F[i - 5], F[i - 11])) + 1;
    }
    cout << F[n];
}
```

## 动态规划原理

能用动态规划解决的问题，需要满足三个条件：最优子结构，无后效性和子问题重叠。

### 最优子结构

具有最优子结构也可能是适合用贪心的方法求解。

注意要确保我们考察了最优解中用到的所有子问题。

1. 证明问题最优解的第一个组成部分是做出一个选择；

2. 对于一个给定问题，在其可能的第一步选择中，假定你已经知道哪种选择才会得到最优解。你现在并不关心这种选择具体是如何得到的，只是假定已经知道了这种选择；

3. 给定可获得的最优解的选择后，确定这次选择会产生哪些子问题，以及如何最好地刻画子问题空间；

4. 证明作为构成原问题最优解的组成部分，每个子问题的解就是它本身的最优解。方法是反证法，考虑加入某个子问题的解不是其自身的最优解，那么就可以从原问题的解中用该子问题的最优解替换掉当前的非最优解，从而得到原问题的一个更优的解，从而与原问题最优解的假设矛盾。

要保持子问题空间尽量简单，只在必要时扩展。

最优子结构的不同体现在两个方面：

1. 原问题的最优解中涉及多少个子问题；

2. 确定最优解使用哪些子问题时，需要考察多少种选择。

子问题图中每个定点对应一个子问题，而需要考察的选择对应关联至子问题顶点的边。

### 无后效性

已经求解的子问题，不会再受到后续决策的影响。

### 子问题重叠

如果有大量的重叠子问题，我们可以用空间将这些子问题的解存储下来，避免重复求解相同的子问题，从而提升效率。

（不过我觉得这三条也太复杂了，不如说能递推的就是DP）

# 基本思路

对于一个能用动态规划解决的问题，一般采用如下思路解决：

1. 将原问题划分为若干 阶段，每个阶段对应若干个子问题，提取这些子问题的特征（称之为 状态）；

2. 寻找每一个状态的可能 决策，或者说是各状态间的相互转移方式（用数学的语言描述就是 状态转移方程）。

3. 按顺序求解每一个阶段的问题。

如果用图论的思想理解，我们建立一个 有向无环图，每个状态对应图上一个节点，决策对应节点间的连边。

## 记忆化搜索

直接用DFS翻译状态转移方程肯定比递推好写，如果仅仅是为了避免子问题的重复求解而降低时间复杂度的话，我们可以用一个数组把DFS得到的结果存起来，访问到已经计算出来的子问题结果时就直接用数组里储存的结果而不是重复求解。

利用记忆化搜索改写上一题代码：
```cpp
#include<iostream>
using namespace std;
constexpr int N = 1e6;
int F[N + 1];

int dfs(int n){
    if(n < 0)return 0x7fffffff;
    if(!n)return 0;
    if(F[n] > 0)return F[n]; // 由于n>0时F_n>0故用0来标记未计算
    return F[n] = std::min(dfs(n-1), std::min(dfs(n-5), dfs(n-11))) + 1;
}

int main(){
    int n;
    cin >> n;
    cout << dfs(n);
}
```
## [例题：洛谷P1775-石子合并（弱化版）](https://www.luogu.com.cn/problem/P1775)

## 题目描述

设有 $N(N \le 300)$ 堆石子排成一排，其编号为 $1,2,3,\cdots,N$。每堆石子有一定的质量 $m_i\ (m_i \le 1000)$。现在要将这 $N$ 堆石子合并成为一堆。每次只能合并相邻的两堆，合并的代价为这两堆石子的质量之和，合并后与这两堆石子相邻的石子将和新堆相邻。合并时由于选择的顺序不同，合并的总代价也不相同。试找出一种合理的方法，使总的代价最小，并输出最小代价。

## 输入格式

第一行，一个整数 $N$。

第二行，$N$ 个整数 $m_i$。

## 输出格式

输出文件仅一个整数，也就是最小代价。

## 样例 #1

### 样例输入 #1

```
4
2 5 3 1
```

### 样例输出 #1

```
22
```

## 题解

考虑合并区间 $[l, r]$ 中石子的子问题，设其为 $F_{l, r}$ ，不难发现 $F_{l, r} = min_{l \leq i < r}(F_{l, i} + F_{i + 1, r}) + \sum_{i=l}^r m_i$ 。递推时以 $F_{i, i+1}, F_{i, i+2} ...$ 次序递推，此方法时间复杂度为 $O(n^3)$ ，而 $n \leq 300$ ，可以接受。

代码：
```cpp
#include<iostream>
using namespace std;
constexpr int N = 300;
int F[N][N]; //下标为0 ~ n-1
int m[N];

int main(){
    int n;
    cin >> n;
    for(int i = 0; i < n; ++i)cin >> m[i];
    for(int k = 1; k < n; ++k){
        for(int i = 0; i < n - k; ++i){
            int x = 0x7fffffff, s = m[i + k];
            for(int j = i; j < i + k; ++j){
                x = min(x, F[i][j] + F[j + 1][i + k]);
                s += m[j];
            }
            F[i][i + k] = x + s;
        }
    }
    cout << F[0][n - 1];
}
```

## [例题：洛谷P1020-[NOIP1999 提高组] 导弹拦截](https://www.luogu.com.cn/problem/P1020)

# [NOIP1999 提高组] 导弹拦截

## 题目描述

某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。

   
输入导弹依次飞来的高度，计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。

## 输入格式

一行，若干个整数，中间由空格隔开。

## 输出格式

两行，每行一个整数，第一个数字表示这套系统最多能拦截多少导弹，第二个数字表示如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。

## 样例 #1

### 样例输入 #1

```
389 207 155 300 299 170 158 65
```

### 样例输出 #1

```
6
2
```

## 提示

对于前 $50\%$ 数据（NOIP 原题数据），满足导弹的个数不超过 $10^4$ 个。该部分数据总分共 $100$ 分。可使用$\mathcal O(n^2)$ 做法通过。  
对于后 $50\%$ 的数据，满足导弹的个数不超过 $10^5$ 个。该部分数据总分也为 $100$ 分。请使用 $\mathcal O(n\log n)$ 做法通过。

对于全部数据，满足导弹的高度为正整数，且不超过 $5\times 10^4$。


此外本题开启 spj，每点两问，按问给分。

NOIP1999 提高组 第一题

---

$\text{upd 2022.8.24}$：新增加一组 Hack 数据。

## 题解

第一小题题意简单来说是对于给定序列求最长不上升子序列长度。

设原序列长度为 $n$，第 $i$ 个元素为 $A_i$ ，令 $F_i$ 为以 $A_i$ 结尾的最长子序列长度，可以列出状态转移方程：

$$ F_i = max_{1 \leq j < i, A_j \geq A_i} (F_j) + 1 $$

此做法时间复杂度为 $O(n^2)$ ，可以拿到一半的分。

这道题的全通过做法之前已经有人讲过了，令 $D_{i,j}$ 表示前 $i$ 个元素中所有长度为 $j$ 的最长不上升子序列最后一位的最小值，令 $D_i$ 长度为 $L_i$ ，可以发现， 若 $A_i > D_{i-1, L_{i-1}}$ ，那么 $D_i$ 与 $D_{i-1}$ 的不同只有将 $D_{i-1}$ 的第一个 $<A_i$ 的元素替换为 $A_i$ ，否则 $D_i$ 为在 $D_{i-1}$ 后添加 $A_i$ ，因此我们只需维护序列 $D$ ，每次读入 $A_i$ 就二分查找到第一个 $<A_i$ 的元素将其替换为 $A_i$ ，若找不到则在后面添加 $A_i$ ，时间复杂度为 $O(nlogn)。这个做法实际上已经不太算是动态规划了。

第二小题可以令 $Q_i$ 为第 $i$ 个最长不上升子序列的最后一位，用贪心策略，每次尽可能把新元素添加至最后一位最小的子序列，不难发现这样形成的 $Q$ 会是单调递增的，故可用二分查找来加速，时间复杂度为 $O(nlogn)$ 。该方法的正确性Dilworth定理证明。

代码：
```cpp
#include<iostream>
#include<algorithm>
using namespace std;

constexpr int N = 1e5;
int D[N];
int Q[N];
int L1, L2;

int main(){
    int x;
    while(cin >> x){
        int i = upper_bound(D, D + L1, x, greater<int>()) - D;
        if(i < L1)D[i] = x;
        else D[L1++] = x;
        i = lower_bound(Q, Q + L2, x) - Q;
        if(i < L2)Q[i] = x;
        else Q[L2++] = x;
    }
    cout << L1 << '\n' << L2;
}
```

# 背包问题

## [例题：洛谷P1048-[NOIP2005 普及组] 采药](https://www.luogu.com.cn/problem/P1048)

## 题目描述

辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”


如果你是辰辰，你能完成这个任务吗？

## 输入格式

第一行有 $2$ 个整数 $T$（$1 \le T \le 1000$）和 $M$（$1 \le  M \le 100$），用一个空格隔开，$T$ 代表总共能够用来采药的时间，$M$ 代表山洞里的草药的数目。

接下来的 $M$ 行每行包括两个在 $1$ 到 $100$ 之间（包括 $1$ 和 $100$）的整数，分别表示采摘某株草药的时间和这株草药的价值。

## 输出格式

输出在规定的时间内可以采到的草药的最大总价值。

## 样例 #1

### 样例输入 #1

```
70 3
71 100
69 1
1 2
```

### 样例输出 #1

```
3
```

## 提示

**【数据范围】**

- 对于 $30\%$ 的数据，$M \le 10$；
- 对于全部的数据，$M \le 100$。

**【题目来源】**

NOIP 2005 普及组第三题

## 题解

设第 $i$ 株草药所需时间为 $t_i$ ，价值为 $w_i$ 。利用动态规划，令 $C_{i, j}$ 为用最多 $i$ 时间采前 $j$ 株草药能达到的最高价值，可以列出状态转移方程：

$$ C_{i, j} = max(C_{i-t_j, j-1} + w_j, C_{i, j-1}) $$

代码：
```cpp
#include<iostream>
using namespace std;
int t[101], w[101], C[1001][101];

int main(){
    int T, M;
    cin >> T >> M;
    for(int i = 1; i <= M; ++i){
        cin >> t[i] >> w[i];
    }
    for(int j = 1; j <= M; ++j){
        for(int i = 1; i <= T; ++i){
            C[i][j] = max(i >= t[j] ? C[i - t[j]][j - 1] + w[j] : 0, C[i][j - 1]);
        }
    }
    cout << C[T][M];
}
```

观察递推式，我们可以发现 $C_{i, j}$ 只依赖 $C_{i - t_j, j-1}$ 和 $C_{i, j-1}$，也就是说我们只需 $C_{_, j-1}$ 就可以推出 $C_{_, j}$ ，我们可以利用双缓冲来减少内存占用：
```cpp
#include<iostream>
using namespace std;
int t[101], w[101], C[1001][2];

int main(){
    int T, M;
    cin >> T >> M;
    for(int i = 1; i <= M; ++i){
        cin >> t[i] >> w[i];
    }
    int b = 0;
    for(int j = 1; j <= M; ++j){
        b = !b;
        for(int i = 1; i <= T; ++i){
            C[i][b] = max(i >= t[j] ? C[i - t[j]][!b] + w[j] : 0, C[i][!b]);
        }
    }
    cout << C[T][b];
}
```

进一步观察发现，$C_i$ 只依赖 $\leq i$ 的 $C_i$ ，所以我们可以不用缓冲，直接在数组里从后往前更新 $C_i$ ，因为前面的 $C_i$ 不依赖后面的 $C_i$ 。由于 $<t_j$ 的 $C_i$ 会被更新为 $C_i$ ，故不需要更新，只需让 $i$ 遍历 $T$ 到 $t_j$ 即可。

```cpp
#include<iostream>
using namespace std;
int t[101], w[101], C[1001];

int main(){
    int T, M;
    cin >> T >> M;
    for(int i = 1; i <= M; ++i){
        cin >> t[i] >> w[i];
    }
    for(int j = 1; j <= M; ++j){
        for(int i = T; i >= t[j]; --i){
            C[i] = max(C[i - t[j]] + w[j], C[i]);
        }
    }
    cout << C[T];
}
```

## [例题：洛谷P1616-疯狂的采药](https://www.luogu.com.cn/problem/P1616)

## 题目背景

此题为纪念 LiYuxiang 而生。

## 题目描述

LiYuxiang 是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同种类的草药，采每一种都需要一些时间，每一种也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”

如果你是 LiYuxiang，你能完成这个任务吗？

此题和原题的不同点：

$1$. 每种草药可以无限制地疯狂采摘。

$2$. 药的种类眼花缭乱，采药时间好长好长啊！师傅等得菊花都谢了！

## 输入格式

输入第一行有两个整数，分别代表总共能够用来采药的时间 $t$ 和代表山洞里的草药的数目 $m$。

第 $2$ 到第 $(m + 1)$ 行，每行两个整数，第 $(i + 1)$ 行的整数 $a_i, b_i$ 分别表示采摘第 $i$ 种草药的时间和该草药的价值。

## 输出格式

输出一行，这一行只包含一个整数，表示在规定的时间内，可以采到的草药的最大总价值。

## 样例 #1

### 样例输入 #1

```
70 3
71 100
69 1
1 2
```

### 样例输出 #1

```
140
```

## 提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $m \le 10^3$ 。
- 对于 $100\%$ 的数据，保证 $1 \leq m \le 10^4$，$1 \leq t \leq 10^7$，且 $1 \leq m \times t \leq 10^7$，$1 \leq a_i, b_i \leq 10^4$。

## 题解

令 $C_i$ 为 $i$ 时间能采到的最高价值。

如果每种药只能采一次，那么添加第 $j$ 种药的状态转移方程为：

$$ C_i^* = min(C_{i-a_j} + b_j, C_i) $$

但是本题题意为每种药可以多次采摘，我们可以在更新数组的时候从前往后更新而不是从后往前更新，这样添加第 $j$ 种药时就可以多次计算第 $j$ 种药的添加。

注意本题答案范围会超过int上限，故使用long long。

代码：
```cpp
#include<iostream>
using namespace std;
using ll = long long;
constexpr int T = 1e7;
constexpr int M = 1e4;
ll C[T + 1];

int main(){
    int m, t;
    cin >> t >> m;
    for(int j = 0; j < m; ++j){
        int a, b;
        cin >> a >> b;
        for(int i = a; i <= t; ++i){
            C[i] = max(C[i - a] + b, C[i]);
        }
    }
    cout << C[t];
}
```

## [例题：洛谷P1855-榨取kkksc03](https://www.luogu.com.cn/problem/P1855)

# 榨取kkksc03

## 题目大意

有 $n$ 个任务需要完成，完成第 $i$ 个任务需要花费 $t_i$ 分钟，产生 $c_i$ 元的开支。

现在有 $T$ 分钟时间，$W$ 元钱来处理这些任务，求最多能完成多少任务。

## 输入格式

第一行三个整数 $n,M,T$，（$1 \le n \le 100$）（$0 \le M \le 200$）（$0 \le T \le 200$）

第 $2$~$n+1$ 行 $m_{i}$ , $t_{i}$

## 输出格式

一行，一个数，表示最多能完成的任务数。

## 样例 #1

### 样例输入 #1

```
6 10 10
1 1
2 3 
3 2
2 5
5 2
4 3
```

### 样例输出 #1

```
4
```

## 题解

与上文的普通背包问题类似，只是背包费用有两个维度。状态转移方程：

$$ A_{i, j} = max(A_{i - t_k, j - c_k} + 1, A_{i, j}) $$

代码：
```cpp
#include<iostream>
using namespace std;
constexpr int M = 200;
constexpr int T = 200;
int A[T + 1][M + 1];

int main(){
    int n, m, t;
    cin >> n >> m >> t;
    while(n--){
        int mk, tk;
        cin >> mk >> tk;
        for(int i = t; i >= tk; --i){
            for(int j = m; j >= mk; --j){
                A[i][j] = max(A[i - tk][j - mk] + 1, A[i][j]);
            }
        }
    }
    cout << A[t][m];
}
```